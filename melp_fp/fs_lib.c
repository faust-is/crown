/*

  fs_lib.c: Fourier series subroutines 

*/

/*  compiler include files  */
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "spbstd.h"
#include "melp.h"
#include "mat.h"
#include "fs.h"
#include "DSPF_sp_fftSPxSP.h"


/*
  A5.2.17 Fourier magnitude calculation and quantization.
  This analysis measures the Fourier magnitudes of the first
  10 pitch harmonics of the prediction residual generated by
  the quantized prediction coefficients. It uses a 512-point
  Fast Fourier Transform (FFT) of a 200 sample window center-
  ed at the end of the frame. First, a set of quantized
  predictor coefficients is calculated from the quantized
  LSF vector (see A5.2.13). Then the residual window is
  generated using the quantized prediction coefficients.
  Next, a 200 sample Hamming window is applied, the signal is
  zero-padded to 512 points, and the complex FFT is performed.
  Finally, the complex FFT output is transformed into
  magnitudes, and the harmonics are found with a spectral
  peak-picking algorithm.
*/

extern const float fft_twiddle[FFTLENGTH];
extern const float fft_spA[FFTLENGTH];
extern const float fft_spB[FFTLENGTH];

static void fft_split_mag (int32_t n, float * pIn, const float *pA, const float *pB, float *pOut)
{
    int32_t i, ii, nn=2*n;
    float Tr, Ti;

    pIn[nn] = pIn[0];
    pIn[nn + 1] = pIn[1];

    for (i = 0; i < n; i++)
    {
        ii = i << 1;
        Tr = pIn[ii] * pA[ii] - pIn[ii + 1] * pA[ii + 1] + pIn[nn - ii] * pB[ii] + pIn[nn - ii + 1] * pB[ii + 1];
        Ti = pIn[ii + 1] * pA[ii] + pIn[ii] * pA[ii + 1] + pIn[nn - ii] * pB[ii + 1] - pIn[nn - ii + 1] * pB[ii];

        Tr = Tr*Tr + Ti*Ti; /* squared absolute value of complex */
        pOut[i] = Tr;
        if (i) pOut[nn - i] = Tr; /* symmetric */

    }
    Tr = pIn[0] - pIn[1];
    pOut[n] = Tr * Tr;
}

/*--------------------------------------------------------------*/
/*      Subroutine FIND_HARM: find Fourier coefficients using   */
/*      FFT of input signal divided into pitch dependent bins.  */
/*--------------------------------------------------------------*/
void find_harm(float* input, float* fsmag, float* fftbuf, float pitch, int16_t num_harm,
       int16_t length)

{
    int16_t  i, j, k, iwidth, i2;
    float temp, avg, fwidth;
    float *mag = 0;

    for (i = 0; i < num_harm; i++)
      fsmag[i] = 1.0f;

    /* Perform peak-picking on FFT of input signal */

    /* Calculate FFT of complex signal in scratch buffer */
    v_zap(input+length, FFTLENGTH - length);
    DSPF_sp_fftSPxSP(FFTLENGTH_HALF, input, &fft_twiddle[0], fftbuf, NULL, 4, 0, FFTLENGTH_HALF);
    /* replace input by its FFT squared absolute values */
    fft_split_mag(FFTLENGTH_HALF, fftbuf, &fft_spA[0], &fft_spB[0], input);
    mag = input;

    /* Implement pitch dependent staircase function */
    fwidth = FFTLENGTH / pitch; /* Harmonic bin width */
    iwidth = (int16_t) fwidth;
    if (iwidth < 2)
        iwidth = 2;
    i2 = iwidth >> 1;
    avg = 0.f;
    if (num_harm > 0.25f * pitch)
        num_harm = 0.25f * pitch;
    for (k = 0; k < num_harm; k++) {
        i = ((k+1)*fwidth) - i2 + 0.5f; /* Start at peak-i2 */
        j = i + findmax(&mag[i],iwidth);
        fsmag[k] = mag[j];
        avg += mag[j];
    }

    /* Normalize Fourier series values to average magnitude */
    temp = num_harm/(avg+ .0001f);
    for (i = 0; i < num_harm; i++) {
        fsmag[i] = sqrt(temp*fsmag[i]);
    }

}

/*--------------------------------------------------------------*/
/*      Subroutine FINDMAX: find maximum value in an            */
/*      input array.                                            */
/*--------------------------------------------------------------*/
int16_t findmax(float input[], int16_t npts)

{
    register int16_t i, maxloc;
    float  maxval, *p_in;

    p_in = &input[0];
    maxloc = 0;
    maxval = input[maxloc];
    for (i = 1; i < npts; i++ ) {
        if (*(++p_in) > maxval) {
            maxloc = i;
            maxval = *p_in;
        }
    }
    return(maxloc);
}

/*--------------------------------------------------------------*/
/*      Subroutine IDFT_REAL: take inverse discrete Fourier     */
/*      transform of real input coefficients.                   */
/*      Assume real time signal, so reduce computation          */
/*      using symmetry between lower and upper DFT              */
/*      coefficients.                                           */
/*--------------------------------------------------------------*/
#define DFTMAX 160

void idft_real(float real[], float signal[], int16_t length)

{
    float idftc[DFTMAX];
    const double inv_len = 1.0 / length, inv_len2 = inv_len + inv_len;
    int32_t i, j, k, k_inc, length2;
    double w;

#ifdef DEBUG_PRINT
    if (length > DFTMAX) {
        fprintf(stderr, "****ERROR: IDFT size too large **** \n");
        exit(1);
    }
#endif
    length2 = (length >> 1) + 1;
    w = TWOPI * inv_len;
    idftc[0] = 1.0f;
    for (i = 1; i < length2; i++ ) {
        idftc[i] = cos(w * i);
        idftc[length - i] = idftc[i];
    }
    real[0] *= inv_len;
    for (i = 1; i < length2-1; i++ ) {
        real[i] *= inv_len2;
    }
    if ((i*2) == length)
        real[i] *= inv_len;
    else
        real[i] *= inv_len2;

    for (i = 0; i < length; i++ ) {
        signal[i] = real[0];
        k_inc = i;
        k = k_inc;
        for (j = 1; j < length2; j++ ) {
            signal[i] += real[j] * idftc[k];
            k += k_inc;
            if (k >= length)
            k -= length;
        }
    }
}

